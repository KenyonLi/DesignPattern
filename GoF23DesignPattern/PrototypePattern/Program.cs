using System;

namespace PrototypePattern
{
    class Program
    {
        /*
            依赖关系的倒置
               抽象不应该该依赖于实现细节，实现细节应该依赖于抽象。

            -抽象A直接依赖于实现细节b

            抽象A——>实现细节b

            -抽象A依赖于抽象B,实现细节b依赖抽象B
             
             抽象A——>抽象B<--实现细节b
          ===============================================================

            动机（Motivation）

                 在软件系统中，经常面临着“某些结构复杂的对象”的创建工作：由于需求
                 的变化，这些对象经常面临着剧烈的变化，但它们却拥有比较稳定一致的接口。

                 如何应对这种变化？ 如何向“客户程序（使用这些对象的程序）”隔离出“
                 这些易变化对象”，从而使得”依赖这些易变对象的客户程序“不随着需求改变
                 而改变？

            意图（Intent）
                 使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新对象。
                                            ——《设计模式》GoF
              =========================================

                Prototype 模式的几个要点


                  Prototype 模式同样用于隔离类对象的使用者和具体
                  类型（易变类）之间的耦合关系，它同样要求这些”易变类“
                  “拥有”稳定的接口。

                  Prototype模式对于“如何创建易变类的实体对象”采用“原型克隆”
                  的方法来做，它使得我们非常灵活地动态创建“拥有某些稳定接口”
                  的新对象——所需工作仅仅是注册一个新类的对象（即原型），然后在所需
                  的地方不断地克隆（Clone）.
                  Prototype模式中的Clone方法可以利用.Net中的Object类的MemberwiseClone()
                  方法或者序列化来实现深拷贝。
                  ================================================



             */
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
