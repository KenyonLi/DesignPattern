using System;

namespace FacadePattern
{
    class Program
    {
        /*
         
            系统的复杂度
              假如我们需要开发一个坦克模拟系统用于模拟系统用于模拟
              坦克车在各种作战环境中的行为，其中坦克系统由引擎、控制器
              、车轮、车身等种子系统构成。

            A方案
                  对于外部接口，与内部产生了耦合。
                  组件的客户
             
             ==================================
             动机（Motivation）
                 上述方案的问题在于组件的客户和组件中各种复杂
                 的子系统有了过多的耦合，随着外部客户程序和各子系统
                 的演化，这种过多的耦合面临很多变化的挑战。

            如何简化外部客户程序和系统间的交互接口？如何将外部客户程序的演化
            和内部子系统的变化之间的依赖相互解耦？
             =======================================
             Facade模式的几个要点
                 从客户程序的角度来看，Facade模式不仅简化了整个组件
                 系统的接口，同时对于组件内部与外部客户程序来说，从某种
                 程序上也达到了一种“解耦”的效果——内部子系统的任务变化不会影响
                 到Facade接口的变化。

                 Facade设计模式更注重从架构的层次去看整个系统，而不是单个类
                 的层次，Facade很多时候更是一种架构设计模式。

                 注意区分Facade模式、Adapter模式、Bridge模式与
                 Decorator模式。Facade模式注重简化接口，Adapter模式
                 注重转化接口，Bridge模式注重分离接口（抽象）与其实现，
                 Decorator模式注重稳定接口的前提下为对象扩展功能。
             */ 
        static void Main(string[] args)
        {
            Console.WriteLine("外观模式");


        }
    }
}
